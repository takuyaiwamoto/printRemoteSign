<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>演出オーバーレイ</title>
    <style>
      :root { --alpha: 0.5; }
      html, body { height: 100%; }
      body {
        margin: 0;
        background: rgba(0,0,0,var(--alpha)); /* 半透明 */
        color: #ffffff;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", Meiryo, sans-serif;
        -webkit-user-select: none;
      }
      .bar {
        position: fixed; inset: 0 0 auto 0; height: 44px;
        -webkit-app-region: drag; /* ドラッグで移動 */
        z-index: 10;
      }
      .btns { position: absolute; right: 8px; top: 8px; display: grid; grid-auto-flow: column; gap: 8px; z-index: 11; }
      .count { position: absolute; right: 12px; top: 10px; z-index: 12; font-size: 44px; color: #fff; text-shadow: 0 0 8px #3b82f6, 0 0 16px #3b82f6, 0 0 24px #3b82f6; display:none; }
      .btn { width: 28px; height: 28px; border-radius: 6px; border: 1px solid rgba(255,255,255,.6); background: rgba(0,0,0,.25); 
             display: grid; place-items: center; cursor: pointer; -webkit-app-region: no-drag; }
      .btn:hover { background: rgba(0,0,0,.35); }
      .icon { width: 16px; height: 16px; display: block; }
      .center { position: fixed; inset: 0; display: grid; place-items: center; pointer-events: none; z-index: 9; }
      /* Pre-count in the exact center (override top-right .count positioning) */
      .center .count {
        position: static; /* override absolute from .count */
        font-size: 160px;
        font-weight: 900;
        letter-spacing: .05em;
        text-shadow: 0 0 14px #3b82f6, 0 0 26px #3b82f6, 0 0 40px #3b82f6;
      }
      .img-wrap { position: fixed; inset: 0; display: grid; place-items: center; z-index: 1; pointer-events: none; width: 100%; height: 100%; transform: translateY(0); will-change: transform; }
      .img-wrap img { width: 100%; height: 100%; object-fit: cover; }
      .move-up { transform: translateY(-120%); }
      .animate { transition: transform 2500ms ease; }
      .hidden { display: none; }
      .label { font-size: 28px; font-weight: 800; letter-spacing: .1em; text-shadow: 0 2px 10px rgba(0,0,0,.35); }
    </style>
  </head>
  <body>
    <div class="bar">
      <div class="btns">
        <button id="btn-full" class="btn" title="最大化">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 9V3h6"/><path d="M21 15v6h-6"/><path d="M21 9V3h-6"/><path d="M3 15v6h6"/>
          </svg>
        </button>
        <button id="btn-clear" class="btn" title="透明">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="9"/><path d="M5 5l14 14"/>
          </svg>
        </button>
      </div>
    </div>
    <div id="centerLabel" class="center hidden">
      <div class="label">しばらくお待ちください</div>
      <div id="preCount" class="count hidden">3</div>
    </div>
    <!-- waiting.png はプロジェクト直下に配置。overlay.html からは1つ上の階層を参照 -->
    <div id="imgWrap" class="img-wrap hidden"><img id="waitImg" src="../waiting.png" alt="waiting" /></div>
    <div id="ovCount" class="count">0秒</div>

    <script>
      const fullBtn = document.getElementById('btn-full');
      const clearBtn = document.getElementById('btn-clear');
      const center = document.getElementById('centerLabel');
      const preCount = document.getElementById('preCount');
      const centerMsg = center?.querySelector('.label');
      const imgWrap = document.getElementById('imgWrap');
      const waitImg = document.getElementById('waitImg');
      let overlayActive = false; // show top-right countdown only during active session
      let preTimer = null;

      // 既定は半透明（--alpha=0.5）
      function setAlpha(a){ document.documentElement.style.setProperty('--alpha', String(a)); }

      fullBtn?.addEventListener('click', () => { window.OverlayApi?.goFullscreen?.(); });

      clearBtn?.addEventListener('click', () => {
        // 背景を完全透明にしてボタンも隠す。中央に「透明中」を表示
        setAlpha(0);
        document.querySelector('.btns')?.classList.add('hidden');
        center?.classList.remove('hidden');
        // 初期状態: メッセージ表示、カウント非表示
        try { centerMsg?.classList.remove('hidden'); preCount?.classList.add('hidden'); } catch(_) {}
        // クリック透過を有効化して下のウィンドウを操作可能に
        setTimeout(() => { window.OverlayApi?.setPassThrough?.(true); }, 50);
        // 透明時は待機画像をフルで表示
        imgWrap.classList.remove('hidden');
      });

      // --- Networking: subscribe to overlayStart via SSE ---
      (function(){
        const qs = new URLSearchParams(location.search);
        const SERVER = (qs.get('server')||'').trim();
        const CHANNEL = (qs.get('channel')||'default').trim();
        if (!SERVER) return;
        function toHttp(u){ return u.replace(/^wss?:\/\//i, (m)=>m.toLowerCase()==='wss://'?'https://':'http://').replace(/\/$/,''); }
        try {
          const es = new EventSource(`${toHttp(SERVER)}/events?channel=${encodeURIComponent(CHANNEL)}`);
          es.addEventListener('overlayStart', () => {
            try { console.log('[overlay] overlayStart'); } catch(_) {}
            // show 3-2-1 countdown in center immediately
            try {
              // メッセージは消してカウントのみ表示（class と style の両方で確実に非表示）
              if (centerMsg) { centerMsg.classList.add('hidden'); centerMsg.style.display = 'none'; }
              if (preCount) { preCount.classList.remove('hidden'); preCount.style.display = 'block'; }
              const preN = Math.max(0, Math.round(window.__preCountSec||3));
              let n = preN; if (preCount) preCount.textContent = String(n||0);
              if (preTimer) { clearInterval(preTimer); preTimer = null; }
              preTimer = setInterval(() => {
                n -= 1;
                if (n > 0) { preCount.textContent = String(n); }
                else { clearInterval(preTimer); preTimer = null; preCount.classList.add('hidden'); preCount.style.display='none'; }
              }, 1000);
            } catch(_) {}
            // Do NOT move here; receiver will trigger actual start via IPC after 3s
            overlayActive = true; // enable top-right countdown display during session
          });
          es.addEventListener('config', (ev) => { try {
            const j = JSON.parse(ev.data);
            if (j && j.data) {
              if (typeof j.data.overlayStaySec !== 'undefined') { const v = Number(j.data.overlayStaySec); if (isFinite(v)) window.__overlayStaySec = Math.max(5, Math.min(120, Math.round(v))); }
              if (typeof j.data.preCountSec !== 'undefined') { const v = Number(j.data.preCountSec); if (isFinite(v)) window.__preCountSec = Math.max(0, Math.min(10, Math.round(v))); }
              if (typeof j.data.overlayWarnSec !== 'undefined') { const v = Number(j.data.overlayWarnSec); if (isFinite(v)) window.__warnSec = Math.max(0, Math.min(60, Math.round(v))); }
              if (typeof j.data.overlayRemainSec !== 'undefined') {
                const left = Math.max(0, Math.floor(Number(j.data.overlayRemainSec)||0));
                const el = document.getElementById('ovCount');
                if (el) {
                  if (overlayActive && left > 0) {
                    el.style.display='block'; el.textContent = left + '秒';
                    const warn = Math.max(0, Math.round(window.__warnSec||10));
                    if (left <= warn) { el.style.color = '#fca5a5'; el.style.textShadow = '0 0 10px #ef4444, 0 0 22px #ef4444, 0 0 34px #ef4444'; }
                    else { el.style.color = '#fff'; el.style.textShadow = '0 0 8px #3b82f6, 0 0 16px #3b82f6, 0 0 24px #3b82f6'; }
                  }
                  else { el.style.display='none'; }
                }
                // When countdown hits 0, start moving back down immediately
                if (left === 0 && imgWrap.classList.contains('move-up')) {
                  try { console.log('[overlay] countdown zero -> moving back'); } catch(_) {}
                  imgWrap.classList.remove('move-up');
                  overlayActive = false;
                  // after descent finishes (2.5s), show waiting message again
                  setTimeout(() => {
                    try {
                      center.classList.remove('hidden');
                      centerMsg && (centerMsg.classList.remove('hidden'), centerMsg.style.display='block');
                      preCount && (preCount.classList.add('hidden'), preCount.style.display='none');
                    } catch(_) {}
                  }, 2500);
                }
              }
            }
          } catch(_) {} });
        } catch(_) {}
      })();

      // Also listen via IPC from receiver renderer (bridge)
      try {
        window.OverlayApi?.onOverlayStart?.(() => {
          try { console.log('[overlay] overlayStart via IPC'); } catch(_) {}
          // Move up immediately on IPC (3s delay handled by receiver)
          try {
            // 確実にメッセージ非表示、カウントも消す（上昇開始時点で完了）
            if (centerMsg) { centerMsg.classList.add('hidden'); centerMsg.style.display = 'none'; }
            if (preCount) { preCount.classList.add('hidden'); preCount.style.display = 'none'; if (preTimer) { clearInterval(preTimer); preTimer = null; } }
          } catch(_) {}
          imgWrap.classList.remove('hidden');
          imgWrap.classList.add('animate');
          requestAnimationFrame(() => { imgWrap.classList.add('move-up'); });
        });
      } catch(_) {}

      // Start central countdown via IPC (from receiver) as well
      try {
        window.OverlayApi?.onPreCount?.(() => {
          try { console.log('[overlay] preCount via IPC'); } catch(_) {}
          if (centerMsg) { centerMsg.classList.add('hidden'); centerMsg.style.display='none'; }
          if (preCount) {
            preCount.classList.remove('hidden'); preCount.style.display='block';
            let n = 3; preCount.textContent = String(n);
            if (preTimer) { clearInterval(preTimer); preTimer = null; }
            preTimer = setInterval(() => {
              n -= 1;
              if (n > 0) preCount.textContent = String(n);
              else { clearInterval(preTimer); preTimer = null; preCount.classList.add('hidden'); preCount.style.display='none'; }
            }, 1000);
          }
          overlayActive = true;
        });
      } catch(_) {}
    </script>
  </body>
  </html>
