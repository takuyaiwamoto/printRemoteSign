<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>演出オーバーレイ</title>
    <style>
      :root { --alpha: 0.5; }
      html, body { height: 100%; }
      body {
        margin: 0;
        background: rgba(0,0,0,var(--alpha)); /* 半透明 */
        color: #ffffff;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", Meiryo, sans-serif;
        -webkit-user-select: none;
      }
      .bar {
        position: fixed; inset: 0 0 auto 0; height: 44px;
        -webkit-app-region: drag; /* ドラッグで移動 */
        z-index: 10;
      }
      .btns { position: absolute; right: 8px; top: 8px; display: grid; grid-auto-flow: column; gap: 8px; z-index: 11; }
      .count { position: absolute; right: 12px; top: 10px; z-index: 12; font-size: 36px; color: #fff; text-shadow: 0 0 8px #3b82f6, 0 0 16px #3b82f6, 0 0 24px #3b82f6; display:none; }
      .btn { width: 28px; height: 28px; border-radius: 6px; border: 1px solid rgba(255,255,255,.6); background: rgba(0,0,0,.25); 
             display: grid; place-items: center; cursor: pointer; -webkit-app-region: no-drag; }
      .btn:hover { background: rgba(0,0,0,.35); }
      .icon { width: 16px; height: 16px; display: block; }
      .center { position: fixed; inset: 0; display: grid; place-items: center; pointer-events: none; z-index: 9; }
      .img-wrap { position: fixed; inset: 0; display: grid; place-items: center; z-index: 1; pointer-events: none; width: 100%; height: 100%; transform: translateY(0); will-change: transform; }
      .img-wrap img { width: 100%; height: 100%; object-fit: cover; }
      .move-up { transform: translateY(-120%); }
      .animate { transition: transform 2500ms ease; }
      .hidden { display: none; }
      .label { font-size: 28px; font-weight: 800; letter-spacing: .1em; text-shadow: 0 2px 10px rgba(0,0,0,.35); }
    </style>
  </head>
  <body>
    <div class="bar">
      <div class="btns">
        <button id="btn-full" class="btn" title="最大化">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 9V3h6"/><path d="M21 15v6h-6"/><path d="M21 9V3h-6"/><path d="M3 15v6h6"/>
          </svg>
        </button>
        <button id="btn-clear" class="btn" title="透明">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="9"/><path d="M5 5l14 14"/>
          </svg>
        </button>
      </div>
    </div>
    <div id="centerLabel" class="center hidden"><div class="label">透明中</div></div>
    <!-- waiting.png はプロジェクト直下に配置。overlay.html からは1つ上の階層を参照 -->
    <div id="imgWrap" class="img-wrap hidden"><img id="waitImg" src="../waiting.png" alt="waiting" /></div>
    <div id="ovCount" class="count">0秒</div>

    <script>
      const fullBtn = document.getElementById('btn-full');
      const clearBtn = document.getElementById('btn-clear');
      const center = document.getElementById('centerLabel');
      const imgWrap = document.getElementById('imgWrap');
      const waitImg = document.getElementById('waitImg');

      // 既定は半透明（--alpha=0.5）
      function setAlpha(a){ document.documentElement.style.setProperty('--alpha', String(a)); }

      fullBtn?.addEventListener('click', () => { window.OverlayApi?.goFullscreen?.(); });

      clearBtn?.addEventListener('click', () => {
        // 背景を完全透明にしてボタンも隠す。中央に「透明中」を表示
        setAlpha(0);
        document.querySelector('.btns')?.classList.add('hidden');
        center?.classList.remove('hidden');
        // クリック透過を有効化して下のウィンドウを操作可能に
        setTimeout(() => { window.OverlayApi?.setPassThrough?.(true); }, 50);
        // 透明時は待機画像をフルで表示
        imgWrap.classList.remove('hidden');
      });

      // --- Networking: subscribe to overlayStart via SSE ---
      (function(){
        const qs = new URLSearchParams(location.search);
        const SERVER = (qs.get('server')||'').trim();
        const CHANNEL = (qs.get('channel')||'default').trim();
        if (!SERVER) return;
        function toHttp(u){ return u.replace(/^wss?:\/\//i, (m)=>m.toLowerCase()==='wss://'?'https://':'http://').replace(/\/$/,''); }
        try {
          const es = new EventSource(`${toHttp(SERVER)}/events?channel=${encodeURIComponent(CHANNEL)}`);
          es.addEventListener('overlayStart', () => {
            try { console.log('[overlay] overlayStart'); } catch(_) {}
            // move up immediately
            try { console.log('[overlay] moving up'); } catch(_) {}
            imgWrap.classList.remove('hidden');
            imgWrap.classList.add('animate');
            requestAnimationFrame(() => {
              imgWrap.classList.add('move-up');
              const backMs = (window.__overlayStaySec||5) * 1000;
              setTimeout(()=>{ try { console.log('[overlay] moving back'); } catch(_) {}; imgWrap.classList.remove('move-up'); }, backMs);
            });
          });
          es.addEventListener('config', (ev) => { try {
            const j = JSON.parse(ev.data);
            if (j && j.data) {
              if (typeof j.data.overlayStaySec !== 'undefined') { const v = Number(j.data.overlayStaySec); if (isFinite(v)) window.__overlayStaySec = Math.max(1, Math.min(60, Math.round(v))); }
              if (typeof j.data.overlayRemainSec !== 'undefined') {
                const left = Math.max(0, Math.floor(Number(j.data.overlayRemainSec)||0));
                const el = document.getElementById('ovCount');
                if (el) { if (left > 0) { el.style.display='block'; el.textContent = left + '秒'; } else { el.style.display='none'; } }
              }
            }
          } catch(_) {} });
        } catch(_) {}
      })();

      // Also listen via IPC from receiver renderer (bridge)
      try {
        window.OverlayApi?.onOverlayStart?.(() => {
          try { console.log('[overlay] overlayStart via IPC'); } catch(_) {}
          imgWrap.classList.remove('hidden');
          imgWrap.classList.add('animate');
          requestAnimationFrame(() => {
            imgWrap.classList.add('move-up');
            const backMs = (window.__overlayStaySec||5) * 1000;
            setTimeout(()=>{ imgWrap.classList.remove('move-up'); }, backMs);
          });
        });
      } catch(_) {}
    </script>
  </body>
  </html>
